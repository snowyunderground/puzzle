<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ぷよぷよ風ゲーム</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .header {
      text-align: center;
      margin: 10px;
    }
    #score, #chain {
      font-size: 1.5em;
      margin: 5px;
    }
    #game-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      background: #222;
      width: 288px;
      height: 576px;
    }
    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 10;
    }
    #start-button {
      font-size: 2em;
      padding: 20px 40px;
      background: #8800ff;
      color: #fff;
      border: none;
      border-radius: 15px;
    }
  </style>
</head>
<body>
  <div class="header">
    <div id="score">スコア: 0</div>
    <div id="chain">連鎖: 0</div>
  </div>
  <div id="game-container">
    <canvas id="game" width="192" height="384"></canvas>
    <div id="start-screen">
      <button id="start-button">ゲームスタート</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const COLS = 6;
    const ROWS = 12;
    const BLOCK_SIZE = 32;
    const FALL_INTERVAL = 600;
    const COLORS = ["red", "blue", "green", "yellow"];
    const scoreEl = document.getElementById("score");
    const chainEl = document.getElementById("chain");
    let board, current, interval, isPaused = true, score = 0, chainCount = 0;

    function createBoard() {
      return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    }

    function newPuyo() {
      const c1 = COLORS[Math.floor(Math.random() * COLORS.length)];
      const c2 = COLORS[Math.floor(Math.random() * COLORS.length)];
      return {
        blocks: [
          { x: 2, y: 0, color: c1 },
          { x: 2, y: 1, color: c2 }
        ],
        rotation: 0
      };
    }

    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x]) drawBlock(x, y, board[y][x]);
        }
      }
      if (current) {
        current.blocks.forEach(b => drawBlock(b.x, b.y, b.color));
      }
    }

    function valid(blocks) {
      return blocks.every(b =>
        b.x >= 0 && b.x < COLS && b.y >= 0 && b.y < ROWS && (!board[b.y][b.x])
      );
    }

    function move(dx, dy) {
      const moved = current.blocks.map(b => ({ ...b, x: b.x + dx, y: b.y + dy }));
      if (valid(moved)) {
        current.blocks = moved;
        return true;
      }
      return false;
    }

    function rotate() {
      const [pivot, target] = current.blocks;
      const dx = target.x - pivot.x;
      const dy = target.y - pivot.y;
      const rotated = { x: pivot.x - dy, y: pivot.y + dx, color: target.color };
      const newBlocks = [pivot, rotated];
      if (valid(newBlocks)) current.blocks[1] = rotated;
    }

    function freeze() {
      for (const b of current.blocks) {
        if (b.y >= 0) board[b.y][b.x] = b.color;
      }
      checkChains();
      current = newPuyo();
      if (!valid(current.blocks)) {
        alert("ゲームオーバー");
        isPaused = true;
        clearInterval(interval);
        document.getElementById("start-screen").style.display = "flex";
      }
    }

    function checkChains() {
      let removed = false;
      const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (!board[y][x] || visited[y][x]) continue;
          const color = board[y][x];
          const chain = [];
          const queue = [[x, y]];
          while (queue.length) {
            const [cx, cy] = queue.pop();
            if (
              cx < 0 || cy < 0 || cx >= COLS || cy >= ROWS ||
              board[cy][cx] !== color || visited[cy][cx]
            ) continue;
            visited[cy][cx] = true;
            chain.push([cx, cy]);
            queue.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
          }
          if (chain.length >= 4) {
            chain.forEach(([cx, cy]) => board[cy][cx] = null);
            score += chain.length * 10;
            chainCount++;
            removed = true;
          }
        }
      }
      if (removed) {
        applyGravity();
        setTimeout(checkChains, 200);
      } else {
        chainCount = 0;
      }
      scoreEl.textContent = "スコア: " + score;
      chainEl.textContent = "連鎖: " + chainCount;
    }

    function applyGravity() {
      for (let y = ROWS - 2; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x] && !board[y+1][x]) {
            let ny = y;
            while (ny + 1 < ROWS && !board[ny+1][x]) {
              board[ny+1][x] = board[ny][x];
              board[ny][x] = null;
              ny++;
            }
          }
        }
      }
    }

    function tick() {
      if (!current || isPaused) return;
      if (!move(0, 1)) {
        freeze();
      }
      draw();
    }

    document.addEventListener("keydown", e => {
      if (isPaused) return;
      if (e.key === "ArrowLeft") move(-1, 0);
      if (e.key === "ArrowRight") move(1, 0);
      if (e.key === "ArrowDown") move(0, 1);
      if (e.key.toLowerCase() === "z") rotate();
    });

    document.getElementById("start-button").onclick = () => {
      document.getElementById("start-screen").style.display = "none";
      board = createBoard();
      current = newPuyo();
      isPaused = false;
      score = 0;
      chainCount = 0;
      interval = setInterval(tick, FALL_INTERVAL);
    };
  </script>
</body>
</html>
