<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ぷよぷよ風ゲーム</title>
  <style>
    body {
      background: #000;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      background: #222;
      margin-top: 10px;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    button {
      font-size: 20px;
      padding: 10px;
      border-radius: 10px;
      border: none;
      background: #444;
      color: white;
    }
    button:active {
      background: #666;
    }
  </style>
</head>
<body>
  <h1>ぷよぷよ風ゲーム</h1>
  <canvas id="game" width="300" height="600"></canvas>
  <div class="controls">
    <button id="left">←</button>
    <button id="rotate">⟳</button>
    <button id="right">→</button>
    <button id="down">↓</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const COLS = 10, ROWS = 20, SIZE = 30;
    const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    const colors = ['red', 'blue', 'green', 'yellow'];

    function randomColor() {
      return Math.floor(Math.random() * colors.length) + 1;
    }

    function createPair() {
      return {
        x: 4,
        y: 0,
        cells: [randomColor(), randomColor()], // 上・下
        rotation: 0
      };
    }

    let pair = createPair();
    let interval = setInterval(drop, 500);
    let fastDropInterval = null;

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (grid[y][x]) drawCell(x, y, grid[y][x]);
        }
      }
      // 操作中のぷよ
      const [a, b] = getPairCells(pair);
      drawCell(a.x, a.y, a.color);
      drawCell(b.x, b.y, b.color);
    }

    function drawCell(x, y, colorIndex) {
      ctx.fillStyle = colors[colorIndex - 1];
      ctx.fillRect(x * SIZE, y * SIZE, SIZE, SIZE);
      ctx.strokeStyle = 'black';
      ctx.strokeRect(x * SIZE, y * SIZE, SIZE, SIZE);
    }

    function getPairCells(p) {
      const [c1, c2] = p.cells;
      let dx = 0, dy = 0;
      switch (p.rotation % 4) {
        case 0: dy = -1; break; // 上
        case 1: dx = 1; break;  // 右
        case 2: dy = 1; break;  // 下
        case 3: dx = -1; break; // 左
      }
      return [
        { x: p.x, y: p.y, color: c2 },
        { x: p.x + dx, y: p.y + dy, color: c1 }
      ];
    }

    function canMove(dx, dy, rotationOffset = 0) {
      const [a, b] = getPairCells({ ...pair, x: pair.x + dx, y: pair.y + dy, rotation: pair.rotation + rotationOffset });
      return [a, b].every(c =>
        c.x >= 0 && c.x < COLS && c.y >= 0 && c.y < ROWS && !grid[c.y]?.[c.x]
      );
    }

    function drop() {
      if (canMove(0, 1)) {
        pair.y++;
      } else {
        fixToGrid();
        applyGravity(); // 落下後に空中ぷよを落とす
        removeMatches();
        pair = createPair();
        if (!canMove(0, 0)) {
          alert('Game Over');
          clearInterval(interval);
        }
      }
      draw();
    }

    function fixToGrid() {
      for (const c of getPairCells(pair)) {
        if (grid[c.y] && grid[c.y][c.x] === 0) grid[c.y][c.x] = c.color;
      }
    }

    function applyGravity() {
      let moved;
      do {
        moved = false;
        for (let y = ROWS - 2; y >= 0; y--) {
          for (let x = 0; x < COLS; x++) {
            if (grid[y][x] && !grid[y + 1][x]) {
              grid[y + 1][x] = grid[y][x];
              grid[y][x] = 0;
              moved = true;
            }
          }
        }
      } while (moved);
    }

    function removeMatches() {
      let matched = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const color = grid[y][x];
          if (!color) continue;
          const directions = [[1,0],[0,1],[-1,0],[0,-1]];
          let stack = [[x,y]];
          let visited = new Set([`${x},${y}`]);
          for (let i = 0; i < stack.length; i++) {
            const [cx, cy] = stack[i];
            for (const [dx, dy] of directions) {
              const nx = cx + dx, ny = cy + dy;
              if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && grid[ny][nx] === color && !visited.has(`${nx},${ny}`)) {
                visited.add(`${nx},${ny}`);
                stack.push([nx, ny]);
              }
            }
          }
          if (stack.length >= 4) {
            for (const [mx, my] of stack) matched[my][mx] = true;
          }
        }
      }
      let found = false;
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (matched[y][x]) {
            grid[y][x] = 0;
            found = true;
          }
        }
      }
      if (found) applyGravity();
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' && canMove(-1, 0)) pair.x--;
      if (e.key === 'ArrowRight' && canMove(1, 0)) pair.x++;
      if (e.key === 'ArrowUp' && canMove(0, 0, 1)) pair.rotation++;
      if (e.key === 'ArrowDown' && !fastDropInterval) {
        fastDropInterval = setInterval(() => drop(), 50);
      }
      draw();
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowDown' && fastDropInterval) {
        clearInterval(fastDropInterval);
        fastDropInterval = null;
      }
    });

    // スマホ用ボタン
    document.getElementById('left').onclick = () => { if (canMove(-1, 0)) pair.x--; draw(); };
    document.getElementById('right').onclick = () => { if (canMove(1, 0)) pair.x++; draw(); };
    document.getElementById('rotate').onclick = () => { if (canMove(0, 0, 1)) pair.rotation++; draw(); };
    document.getElementById('down').ontouchstart = () => {
      if (!fastDropInterval) fastDropInterval = setInterval(() => drop(), 50);
    };
    document.getElementById('down').ontouchend = () => {
      clearInterval(fastDropInterval);
      fastDropInterval = null;
    };

    draw();
  </script>
</body>
</html>
